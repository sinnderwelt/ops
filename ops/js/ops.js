// css - html и body и maincontent - height 100% (transform: translateY(-100%); - проверка, будет ли работать опс), а .wrapper - height: 100%; overflow: hidden; - убирает скрол, не позволяет прокрутку без скрипта

// Анимацию для скрола пишем в css, в maincontent

// Определяем то, с чем мы будем работать. 

const sections = $("section");
const display = $(".maincontent");

// Переменная отменяет скролл по умолчанию

let inScroll = false;

// Навешиваем класс active на видимый блок
// На первый блок, на странице, автоматически ставим класс active

sections.first().addClass("active");



// Функция позвоялющая скролить страницу 
// Делаем так, чтобы при передача функции номеру секции, она эту секцию отображала
// SectionEq - номер секции. Названия могут быть произвольными 

const performTransition = (sectionEq) => {

    // То, что в условии if, будет выполняться лишь в том случае, если переменная - false. Тем самым при скролле анимация не будет начинаться при уже активной анимации - один скрол = одна анимация (без этого условия, один скрол = несколько анимаций - прокрутка через блоки, не последовательное блок - блок, а перескоками). 

    if (inScroll === false) {
        // Когда мы запустим анимацию, то мы inScroll сразу преобразуем в true. 

        inScroll = true;

        // Будем передавать номер и расчитывать позицию 
        // Номер секции умножить на минус сто
        const position = sectionEq * -100;


        // Меняем цвет точек меню в соотношении и фоном блока, чтобы они не сливались
        // В html к секциям добавляем data-sidemenu-theme="white" туда, где меню-кнопки будут белые, а "black", где черные

        // Берем только ту секцию, к которой совершался скрол
        const currentSection = sections.eq(sectionEq);
        // Берем значение этого дата-атрибута
        const menuTheme = currentSection.attr("data-sidemenu-theme");
        // Сохраняем менюшку в переменную
        const sideMenu = $(".fixed-menu_item");
        const sidePoint = $(".point");

        // Если тема - черная, то класс будем навешивать, если нет, то класс будем убирать

        if (menuTheme == "black") {
            // Пишем добавление и снятие класса

            sideMenu.addClass("point--shadowed");
        } else {
            sideMenu.removeClass("point--shadowed");
        }

        // Далее применяем получившееся значение, как css свойства для transform: `translateY(), в процентах`
        display.css({
            transform: `translateY(${position}%)`
        });

        // После совершения скролла. Мы выбираем, из всех секция ту, к которой совершаелся переход, и ей добавляем класс active, а у всех соседей удаляем этот класс

        sections.eq(sectionEq).addClass("active").siblings().removeClass("active");

        // inScroll = true; - запрещает дальнейшую анимацию, так как скрол происходит только при false. Чтобы заново запустить анимацию, нужно переменную вернуть в исходное состояние, чтобы мы снова могли производить действия скролла. Ставим таймер, что через энное время inScroll становится false

        

        setTimeout(() => {
            inScroll = false;


        // Скрол при нажатие на боковое меню (точки)


        // Изменяем активный класс на классе point
        // Находим все элементы списка li - точки и выбираем нужный li и находим индекс его секции, который совпадает с индексом блока. Добавляем активный класс и со всех соседей снимает активный класс

        sidePoint
            .find(".fixed-menu_item")
            .eq(sectionEq)
            .addClass("fixed-menu_active")
            .siblings()
            .removeClass("fixed-menu_active");

        }, 1300);
    }
    
};

// Заведем функцию (scrollViewport), которая определяет к какому блоку скролим. Direction - оргумент функции, ему будем передовать напавление скрола

const scrollViewport = directon => {

    // Отфилтруем из всех секций активную, и узнаем, какая сейчас видна

    const activeSection = sections.filter(".active");

    // Next секция активная дальше по дом - дереву

    const nextSection = activeSection.next();

    // Prev секция активная выше по дом - дереву

    const prevSection = activeSection.prev();


    // Пешем две опции. Для скрола вперед и назад
    
    // (&& nextSection.length) - Чтобы избавить от бага, который скроллит к несущесвующей секции. Нужно проверить, существует ли вообще секция.    
    if (directon === "next" && nextSection.length) {

        // Если совершен скрол, то вызывается функция direction, передаем этой функции номер секции, через index (метод jquery) 
        performTransition(nextSection.index())  

    }

    if (directon === "prev" && prevSection.length) {

        performTransition(prevSection.index())  


    }
}


/////////////////////////////////////////////// ***

// Определяем в какую сторону скролим страницу
// Обрабатываем у объекта window событие wheel

$(window).on("wheel", e => {
    // deltaY - Величина значения при скроле
    // Сохраняем deltaY в переменную
    const deltaY = e.originalEvent.deltaY;

    

    // Напишем условие. Если deltaY больше 0, то страница едет к следующей секции(Вниз = Next)
    if (deltaY > 0) {

        // Вызываем функцию scrollViewpoer, чтобы происходил скролл по секциям
        scrollViewport("next");
    }
    // Напишем условие. Если deltaY меньше 0, то страница едет к предыдущей секции(Наверх = Prev)
    if (deltaY < 0) {

        // Вызываем функцию scrollViewpoer, чтобы происходил скролл по секциям
        scrollViewport("prev");   
    }

    console.log(deltaY);
    
});




///////////////////////////////////////////////// ***



// Скролл при помощи клавиатуры 

$(window).on("keydown", e => {

    // Смотрим какой ключ у клавиши стрелок
    // console.log(e.keyCode)


    // Делаем проверку на то, чтобы при нажатии на стрелочки не были скролла при передвижении по тексту в полях ввода (Импуты, комменты, и тд)

    // Проверяем в каком теге происходит событие и при равниваем в нижний регистр (хз зачем)

    const tagName = e.target.tagName.toLowerCase();

    // Пишем условие 

    if (tagName !== "input" && tagName !== "textarea") {
        // Switch - условный оператор сравнения. Выполняет заданный в него код

    switch (e.keyCode) {
        case 38: // Код стрелочки наверх
        // Предыдущая секция
        // Вызываем написанную выше функцию с нужным параметром
        scrollViewport("prev");

        break;

        case 40: // Код стрелочки вниз
        // Следующая секция
        // Вызываем написанную выше функцию с нужным параметром
        scrollViewport("next");

        break;
      }
    } 
});



//////////////////////////////////////////////////// ***



// При нажатии на ссылку (меню) появляется скрол до нужного блока
// К ссылке в html добавляем data-scroll-to="название секции (например, advantage)", а к секции добавляем data-section-id="название секции, такое же как и у ссылки (например, advantage)"


// На ссылку вешаем обработчик собития-клика и делаем из нее стрелочную ф-цию
$("[data-scroll-to]").click(e => {
    // Убираем прямой переход по ссылке
    e.preventDefault();

    // Делаем так, чтобы команда обращалась только к определенной ссылке. event.currentTarget используется, когда один и тот же обработчик события присваивается нескольким элементам
    const $this = $(e.currentTarget);

    // Присваеваем обработчик события к конкретному атрибуту data-scroll-to
    const target = $this.attr("data-scroll-to");

    // Связываем между собой data-scroll-to и data-section-id
    const reqSection = $(`[data-section-id=${target}]`);
    
    // console.log(reqSection.index()); - смотрим индекс блока, к которому привязана ссылка. Отсчет идет с нуля (первый блок)

    // Вызываем функцию, чтоб все работало, и вуаля - оно шивелится
    performTransition(reqSection.index());
});

